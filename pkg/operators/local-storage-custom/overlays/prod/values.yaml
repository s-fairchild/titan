---
# Values for local-path-provisioner.
# There is no json schema for this helm chart.
# README.md https://github.com/rancher/local-path-provisioner/blob/v0.0.32/deploy/chart/local-path-provisioner/README.md
# Example values.yaml https://github.com/rancher/local-path-provisioner/blob/v0.0.32/deploy/chart/local-path-provisioner/values.yaml

replicaCount: 1
commonLabels: {}
namespaceOverride: ""

image:
  repository: docker.io/rancher/local-path-provisioner
  tag: v0.0.32
  pullPolicy: IfNotPresent

helperImage:
  repository: busybox
  tag: latest

nameOverride: ""
fullnameOverride: ""

## For creating the StorageClass automatically:
storageClass:
  create: true

  ## Set a provisioner name. If unset, a name will be generated.
  provisionerName: rancher.io/local-path

  ## Set StorageClass as the default StorageClass
  ## Ignored if storageClass.create is false
  defaultClass: true

  ## The default volume type this storage class creates, can be "local" or "hostPath"
  defaultVolumeType: hostPath

  ## Set a StorageClass name
  ## Ignored if storageClass.create is false
  name: local-path-default

  ## ReclaimPolicy field of the class, which can be either Delete or Retain
  reclaimPolicy: Retain

  ## volumeBindingMode field controls when volume binding and dynamic provisioning should occur, can be  "Immediate" or "WaitForFirstConsumer"
  volumeBindingMode: WaitForFirstConsumer

  ## Set a path pattern, if unset the default will be used
  pathPattern: "{{ .PVC.Namespace }}-{{ .PVC.Name }}"

# nodePathMap is the place user can customize where to store the data on each node.
# 1. If one node is not listed on the nodePathMap, and Kubernetes wants to create volume on it, the paths specified in
#    DEFAULT_PATH_FOR_NON_LISTED_NODES will be used for provisioning.
# 2. If one node is listed on the nodePathMap, the specified paths will be used for provisioning.
#     1. If one node is listed but with paths set to [], the provisioner will refuse to provision on this node.
#     2. If more than one path was specified, the path would be chosen randomly when provisioning.
#
# The configuration must obey following rules:
# 1. A path must start with /, a.k.a an absolute path.
# 2. Root directory (/) is prohibited.
# 3. No duplicate paths allowed for one node.
# 4. No duplicate node allowed.
nodePathMap:
  - node: DEFAULT_PATH_FOR_NON_LISTED_NODES
    paths:
      - /mnt/local-path/default

# `sharedFileSystemPath` allows the provisioner to use a filesystem that is mounted on all
# nodes at the same time. In this case all access modes are supported: `ReadWriteOnce`,
# `ReadOnlyMany` and `ReadWriteMany` for storage claims. In addition
# `volumeBindingMode: Immediate` can be used in  StorageClass definition.
# Please note that `nodePathMap` and `sharedFileSystemPath` are mutually exclusive.
# If `sharedFileSystemPath` is used, then `nodePathMap` must be set to `[]`.
# sharedFileSystemPath: ""

# `storageClassConfigs` allows the provisioner to manage multiple independent storage classes.
# Each storage class must have a unique name, and contains the same fields as shown above for
# a single storage class setup, EXCEPT for the provisionerName, which is the same for all
# storage classes, and name, which is the key of the map.
storageClassConfigs:
  local-path-default:
    storageClass:
      create: true
      defaultClass: true
      defaultVolumeType: hostPath
      reclaimPolicy: Retain
    nodePathMap: [{"node":"DEFAULT_PATH_FOR_NON_LISTED_NODES"}, "paths":["/mnt/local-path/appdata"]]
  local-path-appdata:
    storageClass:
      create: true
      defaultClass: false
      defaultVolumeType: hostPath
      reclaimPolicy: Retain
    nodePathMap: [{"node":"k3s-agent-0"}, "paths":["/mnt/local-path/appdata"]]
  local-path-cctv:
    storageClass:
      create: true
      defaultClass: false
      defaultVolumeType: hostPath
      reclaimPolicy: Retain
    # sharedFileSystemPath: ""
    nodePathMap: [{"node":"k3s-agent-0"}, "paths":["/mnt/local-path/cctv"]]

rbac:
  # Specifies whether RBAC resources should be created
  create: true

serviceAccount:
  # Specifies whether a ServiceAccount should be created
  create: true
  # The name of the ServiceAccount to use.
  # If not set and create is true, a name is generated using the fullname template
  # name:

nodeSelector:
  node-role.kubernetes.io/control-plane: "true"

tolerations:
  - key: node.kubernetes.io/disk-pressure
    operator: Exists
    effect: NoSchedule
  - key: "CriticalAddonsOnly"
    operator: "Exists"
  - key: "node-role.kubernetes.io/control-plane"
    operator: "Exists"
    effect: "NoSchedule"
  - key: "node-role.kubernetes.io/master"
    operator: "Exists"
    effect: "NoSchedule"

podDisruptionBudget:
  enabled: false

configmap:
  # specify the config map name
  name: local-path-config
  # specify the custom script for setup and teardown
  setup: |-
    #!/bin/sh
    set -eu
    mkdir -m 0777 -p "$VOL_DIR"
  teardown: |-
    #!/bin/sh
    set -eu
    rm -rf "$VOL_DIR"
  helperPod:
    # Allows to run the helper pod in another namespace. Uses release namespace by default.
    namespaceOverride: local-path-storage
    name: "helper-pod"
    annotations: {}
    tolerations:
    - key: node.kubernetes.io/disk-pressure
      operator: Exists
      effect: NoSchedule
    - key: "CriticalAddonsOnly"
      operator: "Exists"
    - key: "node-role.kubernetes.io/control-plane"
      operator: "Exists"
      effect: "NoSchedule"
    - key: "node-role.kubernetes.io/master"
      operator: "Exists"
      effect: "NoSchedule"

# Extra arguments to pass to the CLI
extraArgs: []
