---
# https://doc.traefik.io/traefik-hub/api-gateway/reference/install/ref-helm
# yaml-language-server: $schema=https://raw.githubusercontent.com/traefik/traefik-helm-chart/refs/heads/master/traefik/values.schema.json
#
# Human readable values: https://github.com/traefik/traefik-helm-chart/blob/master/traefik/values.yaml
# Values Markdown: https://github.com/traefik/traefik-helm-chart/blob/master/traefik/VALUES.md
deployment:
  podAnnotations:
    prometheus.io/port: "8082"
    prometheus.io/scrape: "true"
providers:
  kubernetesCRD:
    enabled: true
    allowCrossNamespace: true
    allowExternalNameServices: true
    # -- Allows to return 503 when there is no endpoints available
    allowEmptyServices: true
  kubernetesIngress:
    enabled: true
    allowExternalNameServices: true
    allowEmptyServices: true
    # IP used for Kubernetes Ingress endpoints
    publishedService:
      # -- Enable [publishedService](https://doc.traefik.io/traefik/providers/kubernetes-ingress/#publishedservice)
      enabled: true
    # -- Defines whether to use Native Kubernetes load-balancing mode by default.
    nativeLBByDefault: true
    # -- Defines whether to make prefix matching strictly comply with the Kubernetes Ingress specification.
    strictPrefixMatching: false
priorityClassName: "system-cluster-critical"
nodeSelector:
  node-role.kubernetes.io/control-plane: "true"
image:
  registry: docker.io
  repository: "rancher/mirrored-library-traefik"
  tag: "3.3.2"
  pullPolicy: IfNotPresent
tolerations:
- key: "CriticalAddonsOnly"
  operator: "Exists"
- key: "node-role.kubernetes.io/control-plane"
  operator: "Exists"
  effect: "NoSchedule"
- key: "node-role.kubernetes.io/master"
  operator: "Exists"
  effect: "NoSchedule"
# udp:
  # services:
    # udp:
      # loadbalancer:
        # servers:
          # - address: "10.50.0.24:8554/udp" # Replace with your actual service IP and port
    # stream:
      # loadbalancer:
        # servers:
          # - address: "10.50.0.24:8554" # Replace with your actual service IP and port
  # routers:
    # udp:
      # entrypoints:
        # - "udp"
      # service: "udp"
    # stream:
      # entrypoints:
        # - "stream"
      # service: "stream"
ports:
  rtspudp:
    transport:
      lifeCycle:
        requestAcceptGraceTimeout: 42
        graceTimeOut: 42
      respondingTimeouts:
        readTimeout: 42
        writeTimeout: 42
        idleTimeout: 42
    proxyProtocol:
      insecure: true
      trustedIPs:
        - "127.0.0.1"
        - "10.50.0.0/24"
    forwardedHeaders:
      insecure: true
      trustedIPs:
        - "127.0.0.1"
        - "10.50.0.0/24"
    ipFamilyPolicy: "SingleStack"
    ipFamilies:
      - IPv4
    address: '10.50.0.24:8554/udp'
    udp:
      timeout: 30s
    expose:
      default: true
    port: 8554
    exposedPort: 8554
    targetPort: rtspudp
    protocol: UDP
  rtsptcp:
    transport:
      lifeCycle:
        requestAcceptGraceTimeout: 42
        graceTimeOut: 42
      respondingTimeouts:
        readTimeout: 42
        writeTimeout: 42
        idleTimeout: 42
    proxyProtocol:
      insecure: true
      trustedIPs:
        - "127.0.0.1"
        - "10.50.0.0/24"
    forwardedHeaders:
      insecure: true
      trustedIPs:
        - "127.0.0.1"
        - "10.50.0.0/24"
    ipFamilyPolicy: "SingleStack"
    ipFamilies:
      - IPv4
    address: '10.50.0.24:8554/tcp'
    expose:
      default: true
    port: 8555
    exposedPort: 8555
    targetPort: rtsptcp
    protocol: TCP
  traefik:
    port: 9000
    # -- You SHOULD NOT expose the traefik port on production deployments.
    # If you want to access it from outside your cluster,
    # use `kubectl port-forward` or create a secure ingress
    expose:
      default: false
      internal: true
    exposedPort: 9000
    protocol: TCP
  web:
    port: 80
    expose:
      default: true
    exposedPort: 80
    targetPort: web
    protocol: TCP
    # Added in 2.2, you can make permanent redirects via entrypoints.
    # https://docs.traefik.io/routing/entrypoints/#redirection
    redirections:
      entryPoint:
        to: websecure
        scheme: https
        permanent: false
    # Trust forwarded  headers information (X-Forwarded-*).
    forwardedHeaders:
      trustedIPs: ["10.50.0.0/24"]
      insecure: false
  websecure:
    ## -- Enable this entrypoint as a default entrypoint. When a service doesn't explicitly set an entrypoint it will only use this entrypoint.
    asDefault: true
    port: 443
    expose:
      default: true
    exposedPort: 443
    targetPort: websecure
    protocol: TCP
    ## -- Specify an application protocol. This may be used as a hint for a Layer 7 load balancer.
    appProtocol: https
    #
    ## -- Enable HTTP/3 on the entrypoint
    ## Enabling it will also enable http3 experimental feature
    ## https://doc.traefik.io/traefik/routing/entrypoints/#http3
    ## There are known limitations when trying to listen on same ports for
    ## TCP & UDP (Http3). There is a workaround in this chart using dual Service.
    ## https://github.com/kubernetes/kubernetes/issues/47249#issuecomment-587960741
    http3:
      enabled: false
    ## -- Trust forwarded  headers information (X-Forwarded-*).
    forwardedHeaders:
      trustedIPs: ["10.50.0.0/24"]
      insecure: false
  metrics:
    # -- When using hostNetwork, use another port to avoid conflict with node exporter:
    # https://github.com/prometheus/prometheus/wiki/Default-port-allocations
    port: 9100
    expose:
      default: false
    exposedPort: 9100
    protocol: TCP
service:
  annotations: {}
  labels: {}
  enabled: true
  # If seperate pods are used for tcp and udp, metallb IP sharing must be configured
  single: false
  type: LoadBalancer
  ipFamilyPolicy: "SingleStack"
  spec:
    externalTrafficPolicy: Cluster
  ipFamilies:
    - IPv4
  loadBalancerSourceRanges:
  - 10.50.0.0/24
  ## -- An additional and optional internal Service.
  ## Same parameters as external Service
  additionalServices:
    internal:
      type: ClusterIP
      enabled: true
      labels: {}
      annotations: {}
      spec: {}
      single: false
      ipFamilyPolicy: "SingleStack"
      ipFamilies:
        - IPv4
      loadBalancerSourceRanges:
      - 10.11.0.0/16
      - 10.10.0.0/16
      - 10.16.0.0/16
      - 10.100.0.0/16
logs:
  general:
    # format: json
    # -- Alternative logging levels are DEBUG, PANIC, FATAL, ERROR, WARN, and INFO.
    # level: INFO
    level: DEBUG
  access:
    enabled: true
    addInternals: false
    fields:
      headers:
        defaultmode: keep
# persistence:
  # # -- Enable persistence using Persistent Volume Claims
  # # ref: http://kubernetes.io/docs/user-guide/persistent-volumes/.
  # # It can be used to store TLS certificates along with `certificatesResolvers.<name>.acme.storage`  option
  # enabled: true
  # name: data
  # existingClaim: ""
  # accessMode: ReadWriteOnce
  # size: 128Mi
  # storageClass: "local-path-default"
  # volumeName: ""
  # path: /data
  # annotations: {}
  # # -- Only mount a subpath of the Volume into the pod
  # subPath: ""
# certificatesResolvers:
  # traefik:
    # acme:
      # email: "steve51516@gmail.com"
      # storage: "/data/acme.json"
      # httpChallenge:
        # # Entry point to use during the ACME HTTP-01 challenge.
        # entryPoint: "web"
hostNetwork: false
rbac:
  enabled: true
  # If set to false, installs ClusterRole and ClusterRoleBinding so Traefik can be used across namespaces.
  # If set to true, installs Role and RoleBinding. Providers will only watch target namespace.
  namespaced: false
# -- The service account the pods will use to interact with the Kubernetes API
serviceAccount:
  # If set, an existing service account is used
  # If not set, a service account is created automatically using the fullname template
  name: ""
